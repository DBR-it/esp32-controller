{% if not allow_preprocessor %}
# NOTE:
# If you see an error about unknown directives here, you must enable Jinja
# preprocessing in your ESPHome environment. For example:
#
# esphome:
#   name: smart_controller
#   allow_preprocessor: true
#
# Then remove these lines after enabling it.
{% endif %}

# ===========================================
# ESP32-C6 Hybrid Controller
# ===========================================
# This configuration can switch between:
#  - Wi-Fi (if use_ethernet = "false")
#  - Ethernet with W5500 (if use_ethernet = "true")
#
# Displays different content on the SSD1306 OLED
# depending on whether Wi-Fi or Ethernet is active.
# Also uses fallback AP if Wi-Fi fails.
# 
# Adjust the substitutions below and recompile to
# change modes or rename entities.
# ===========================================

# -------------------------------------------------
# Substitutions: variables that can be referenced
# throughout the config, making it easy to update
# certain values in one place.
# -------------------------------------------------
substitutions:
  device_name: "smart_controller"                  # Main name for the ESPHome device
  use_ethernet: "false"                            # Set to "true" to enable Ethernet (W5500), "false" for Wi-Fi
  fallback_ssid: "Smart Fallback Hotspot"          # SSID for fallback AP if Wi-Fi fails
  fallback_password: "DefaultPassword123"          # Password for fallback AP
  ota_password: "2eac13bfeea21fd59a7926e874d5127a" # OTA password
  display_switch_name: "Display On/Off"            # Name for the OLED display switch
  button1_name: "Button 1"                         # Name for Button 1
  button2_name: "Button 2"                         # Name for Button 2
  button4_name: "Button 4"                         # Name for Button 4

# -------------------------------------------------
# Primary configuration for the ESPHome device.
# \"name\" is how Home Assistant recognizes this node.
# IMPORTANT: If using the Home Assistant Add-on,
# you may need: allow_preprocessor: true
# -------------------------------------------------
esphome:
  name: ${device_name}
  allow_preprocessor: true


# -------------------------------------------------
# Board & Framework: Using ESP32-C6 with ESP-IDF
# -------------------------------------------------
esp32:
  board: esp32-c6-devkitc-1
  framework:
    type: esp-idf

# -------------------------------------------------
# Logger: Enables logs from the device.
# -------------------------------------------------
logger:

# -------------------------------------------------
# OTA: Over-The-Air updates with a password.
# -------------------------------------------------
ota:
  - platform: esphome
    password: "${ota_password}"

# -------------------------------------------------
# Conditional Networking:
# We only include Ethernet if use_ethernet == "true"
# Otherwise, we enable Wi-Fi.
# -------------------------------------------------
{% if use_ethernet == "true" %}
ethernet:
  type: w5500
  cs_pin: GPIO4
  mosi_pin: GPIO5
  miso_pin: GPIO7
  clk_pin: GPIO6
  interrupt_pin: GPIO10
  reset_pin: GPIO3

{% else %}
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  reboot_timeout: 0s
  ap:
    ssid: "${fallback_ssid}"
    password: "${fallback_password}"

{% endif %}

# -------------------------------------------------
# Web Server: Allows local access on port 80.
# -------------------------------------------------
web_server:
  port: 80

# -------------------------------------------------
# I2C Setup for OLED Display & Future Sensors
# -------------------------------------------------
i2c:
  sda: GPIO18
  scl: GPIO19
  scan: true

# -------------------------------------------------
# Font Configuration for the OLED Display
# -------------------------------------------------
font:
  - file: "fonts/RobotoMono-Regular.ttf"
    id: font1
    size: 10

# -------------------------------------------------
# Display Switch: Allows turning the OLED on/off
# -------------------------------------------------
switch:
  - platform: template
    name: "${display_switch_name}"
    id: display_switch
    optimistic: true
    restore_mode: ALWAYS_ON

# -------------------------------------------------
# SSD1306 OLED Display Configuration
# We customize what is displayed based on Wi-Fi or Ethernet usage.
# -------------------------------------------------
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x32"
    address: 0x3C
    id: ssd1306_display
    pages:
      - id: page1
        lambda: |-
          it.clear();

          // We'll show different info depending on the mode
          {% if use_ethernet == "true" %}
          // Just show that we're in Ethernet mode and the IP Address
          it.printf(0, 0, id(font1), "Ethernet Mode");
          it.printf(0, 15, id(font1), "IP: %s", id(ip_address).state.c_str());

          {% else %}
          // Wi-Fi Mode: show signal strength loading screen and so on
          static int load_time = 0;
          static float last_signal_strength = -100.0;

          // If no IP or still loading for first 15 cycles (~15s)
          if (id(ip_address).state.empty() || load_time < 15) {
            // Simple loading animation
            load_time++;
            int progress = (load_time * 100) / 15;
            if (progress > 100) progress = 100;

            // Draw a border & fill for progress bar
            it.rectangle(10, 20, 108, 10);
            it.filled_rectangle(12, 22, (104 * progress) / 100, 6);

            // Show percentage
            it.printf(54, 5, id(font1), "%d%%", progress);

          } else {
            float strength = id(wifi_signal_sensor).state;

            if (abs(strength - last_signal_strength) > 5) {
                last_signal_strength = strength;
            }

            // Draw Wi-Fi bars
            int x = 0;
            int y = 15;
            if (strength > -80) it.filled_rectangle(x + 10, y - 4, 3, 4);
            if (strength > -70) it.filled_rectangle(x + 15, y - 6, 3, 6);
            if (strength > -60) it.filled_rectangle(x + 20, y - 8, 3, 8);
            if (strength > -50) it.filled_rectangle(x + 25, y - 10, 3, 10);
            if (strength > -40) it.filled_rectangle(x + 30, y - 12, 3, 12);

            // Show IP
            it.printf(0, 22, id(font1), "IP: %s", id(ip_address).state.c_str());

            // Display a placeholder or uptime in top-right
            int uptime_seconds = (int) id(uptime_sensor).state;
            int days = uptime_seconds / 86400;
            int hours = (uptime_seconds % 86400) / 3600;
            int minutes = (uptime_seconds % 3600) / 60;
            it.printf(70, 5, id(font1), "%dd %dh %dm", days, hours, minutes);
          }
          {% endif %}

      - id: empty_page
        lambda: |-
          it.clear();

# -------------------------------------------------
# Binary Sensors: Example GPIO Inputs
# -------------------------------------------------
binary_sensor:
  - platform: gpio
    name: "${button1_name}"
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
    filters:
      - invert:

  - platform: gpio
    name: "${button2_name}"
    pin:
      number: GPIO14
      mode: INPUT_PULLUP
    filters:
      - invert:

  - platform: gpio
    name: "${button4_name}"
    pin:
      number: GPIO16
      mode: INPUT_PULLUP
    filters:
      - invert:

# -------------------------------------------------
# Sensors: Wi-Fi or Ethernet mode adjustments
# We'll define Wi-Fi signal only if use_ethernet == \"false\"
# -------------------------------------------------
sensor:
  {% if use_ethernet == "true" %}
  # In Ethernet mode, no Wi-Fi signal sensor
  # We still define an uptime sensor
  - platform: uptime
    name: "Uptime (Ethernet)"
    id: uptime_sensor
    update_interval: 60s

  {% else %}
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: uptime
    name: "Uptime (Wi-Fi)"
    id: uptime_sensor
    update_interval: 60s
  {% endif %}

# -------------------------------------------------
# Text Sensors: Provide IP address, etc.
# The 'wifi_info' platform is no issue even if we're on Ethernet;
# but if you prefer, you could conditionally skip it for Ethernet
# -------------------------------------------------
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: ip_address
    ssid:
      name: "WiFi SSID"
