esphome:
  name: my_smart_controller
  allow_preprocessor: true  # <-- ENABLE JINJA

substitutions:
  # ~~~~~~~~~~~~~~~~ CUSTOMIZE BELOW ~~~~~~~~~~~~~~~~~~
  device_name: "my_smart_controller"  # Main name in Home Assistant
  use_ethernet: "false"               # "true" = Ethernet, "false" = Wi-Fi
  fallback_ssid: "My Fallback AP"     # AP if Wi-Fi fails
  fallback_password: "Fallback123"    # Password for fallback AP
  ota_password: "2eac13bfeea21fd59a7926e874d5127a"
  display_switch_name: "Display On/Off"
  button1_name: "Button 1"
  button2_name: "Button 2"
  button4_name: "Button 4"
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

esp32:
  board: esp32-c6-devkitc-1
  framework:
    type: esp-idf

logger:

api:

ota:
  - platform: esphome
    password: !secret ota_password  # Or you can inline: password: "2eac13bfeea21fd59a7926e874d5127a"

{% if use_ethernet == "true" %}
# -------------------------------------------------
# Ethernet: W5500
# -------------------------------------------------
ethernet:
  type: w5500
  cs_pin: GPIO4
  mosi_pin: GPIO5
  miso_pin: GPIO7
  clk_pin: GPIO6
  interrupt_pin: GPIO10
  reset_pin: GPIO3

{% else %}
# -------------------------------------------------
# Wi-Fi Configuration
# -------------------------------------------------
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  reboot_timeout: 0s
  ap:
    ssid: "${fallback_ssid}"
    password: "${fallback_password}"
{% endif %}

# -------------------------------------------------
# Web Server for local access and debugging
# -------------------------------------------------
web_server:
  port: 80

# -------------------------------------------------
# I2C for the SSD1306 display or future sensors
# -------------------------------------------------
i2c:
  sda: GPIO18
  scl: GPIO19
  scan: true

# -------------------------------------------------
# Fonts for the display
# -------------------------------------------------
font:
  - file: "fonts/RobotoMono-Regular.ttf"
    id: font1
    size: 10

# -------------------------------------------------
# Display Switch
# -------------------------------------------------
switch:
  - platform: template
    name: "${display_switch_name}"
    id: display_switch
    optimistic: true
    restore_mode: ALWAYS_ON

# -------------------------------------------------
# SSD1306 Display - shows different info depending on Wi-Fi vs. Ethernet
# -------------------------------------------------
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x32"
    address: 0x3C
    id: ssd1306_display
    pages:
      - id: main_page
        lambda: |-
          it.clear();
          {% if use_ethernet == "true" %}
            // Simple label for Ethernet + IP
            it.printf(0, 0, id(font1), "Ethernet Mode");
            it.printf(0, 15, id(font1), "IP: %s", id(ip_address).state.c_str());
          {% else %}
            // Wi-Fi Mode with a simple loading animation & signal bars
            static int load_time = 0;
            static float last_signal_strength = -100.0;

            if (id(ip_address).state.empty() || load_time < 15) {
              load_time++;
              int progress = (load_time * 100) / 15;
              if (progress > 100) progress = 100;

              it.rectangle(10, 20, 108, 10);
              it.filled_rectangle(12, 22, (104 * progress) / 100, 6);
              it.printf(54, 5, id(font1), "%d%%", progress);
            } else {
              float strength = id(wifi_signal_sensor).state;
              if (abs(strength - last_signal_strength) > 5) {
                last_signal_strength = strength;
              }

              // Draw Wi-Fi bars
              int x = 0, y = 15;
              if (strength > -80) it.filled_rectangle(x + 10, y - 4, 3, 4);
              if (strength > -70) it.filled_rectangle(x + 15, y - 6, 3, 6);
              if (strength > -60) it.filled_rectangle(x + 20, y - 8, 3, 8);
              if (strength > -50) it.filled_rectangle(x + 25, y - 10, 3, 10);
              if (strength > -40) it.filled_rectangle(x + 30, y - 12, 3, 12);

              it.printf(0, 22, id(font1), "IP: %s", id(ip_address).state.c_str());

              // Uptime
              int uptime_seconds = (int) id(uptime_sensor).state;
              int days = uptime_seconds / 86400;
              int hours = (uptime_seconds % 86400) / 3600;
              int minutes = (uptime_seconds % 3600) / 60;
              it.printf(70, 5, id(font1), "%dd %dh %dm", days, hours, minutes);
            }
          {% endif %}

      - id: empty_page
        lambda: |-
          it.clear();

# -------------------------------------------------
# Example GPIO Buttons
# -------------------------------------------------
binary_sensor:
  - platform: gpio
    name: "${button1_name}"
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
    filters:
      - invert:

  - platform: gpio
    name: "${button2_name}"
    pin:
      number: GPIO14
      mode: INPUT_PULLUP
    filters:
      - invert:

  - platform: gpio
    name: "${button4_name}"
    pin:
      number: GPIO16
      mode: INPUT_PULLUP
    filters:
      - invert:

# -------------------------------------------------
# Sensors: define Wi-Fi signal only if using Wi-Fi,
# otherwise skip. Everyone gets an uptime sensor.
# -------------------------------------------------
sensor:
  {% if use_ethernet == "true" %}
  - platform: uptime
    id: uptime_sensor
    name: "Ethernet Uptime"
    update_interval: 60s

  {% else %}
  - platform: wifi_signal
    id: wifi_signal_sensor
    name: "WiFi Signal Strength"
    update_interval: 60s

  - platform: uptime
    id: uptime_sensor
    name: "WiFi Uptime"
    update_interval: 60s
  {% endif %}

# -------------------------------------------------
# Text Sensor: Wi-Fi Info for IP Address
# (Works even if on Ethernet; or you can skip it)
# -------------------------------------------------
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: ip_address
    ssid:
      name: "WiFi SSID"
